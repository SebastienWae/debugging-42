"use strict";(self.webpackChunk_42_debuggers=self.webpackChunk_42_debuggers||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"defaultSidebar":[{"type":"link","label":"Home","href":"/debugging-42/","docId":"home"},{"type":"link","label":"Methodology","href":"/debugging-42/methodology","docId":"methodology"},{"type":"category","label":"Debuggers","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"LLDB","href":"/debugging-42/debuggers/lldb","docId":"debuggers/lldb"}],"href":"/debugging-42/category/debuggers"},{"type":"category","label":"Dynamic Analyzers","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Sanitizers","href":"/debugging-42/dynamic-analyzers/sanitizers","docId":"dynamic-analyzers/sanitizers"},{"type":"link","label":"Valgrind","href":"/debugging-42/dynamic-analyzers/valgrind","docId":"dynamic-analyzers/valgrind"}],"href":"/debugging-42/category/dynamic-analyzers"},{"type":"category","label":"Static Analyzers","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Clang Static Analyzer","href":"/debugging-42/static-analyzers/clang_static_analyzer","docId":"static-analyzers/clang_static_analyzer"},{"type":"link","label":"GCC Static Analyzer","href":"/debugging-42/static-analyzers/gcc_static_analyzer","docId":"static-analyzers/gcc_static_analyzer"}],"href":"/debugging-42/category/static-analyzers"}]},"docs":{"debuggers/lldb":{"id":"debuggers/lldb","title":"LLDB","description":"LLDB is a debugger that allows you to monitor and change a program as it is running. For example, it allows you to pause a process when a condition is reached, execute a function step by step or even change the value of a variable at runtime.","sidebar":"defaultSidebar"},"dynamic-analyzers/sanitizers":{"id":"dynamic-analyzers/sanitizers","title":"Sanitizers","description":"Besides UndefinedBehaviorSanitizer, multiple sanitizers cannot be used at the same time.","sidebar":"defaultSidebar"},"dynamic-analyzers/valgrind":{"id":"dynamic-analyzers/valgrind","title":"Valgrind","description":"Even though Valgrind is mostly used to find memory leaks, it can do a lot more. It is a made of multiple tools that can help you find various types of errors in your code.","sidebar":"defaultSidebar"},"home":{"id":"home","title":"Home","description":"The content is written with a focus on macOS as it is the OS used at 42 Mulhouse, it should mostly work the same on Linux.","sidebar":"defaultSidebar"},"methodology":{"id":"methodology","title":"Methodology","description":"This section is not ready yet...","sidebar":"defaultSidebar"},"static-analyzers/clang_static_analyzer":{"id":"static-analyzers/clang_static_analyzer","title":"Clang Static Analyzer","description":"Static analyzer are not magic, they will not catch all errors and can report false positives.","sidebar":"defaultSidebar"},"static-analyzers/gcc_static_analyzer":{"id":"static-analyzers/gcc_static_analyzer","title":"GCC Static Analyzer","description":"Static analyzer are not magic, they will not catch all errors and can report false positives.","sidebar":"defaultSidebar"}}}')}}]);